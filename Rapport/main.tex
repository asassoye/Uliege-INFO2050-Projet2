\input{preamble.tex}
\usepackage{clrscode3e}

\begin{document}

\subfile{titlepage.tex}

\section{Analyse théorique}
\subsection{} %a
\subsection{} %b
	
\subsection{La structure de labyrinthe} %c
La structure maze est composée de 4 éléments.
\begin{itemize}
\item size : contient la taille du labyrinthe. Pour une taille N, le labyrinthe sera un carré N x N.
\item unionFind : contient l'ensemble disjoint qui a été utilisé pour créer le labyrinthe.
\item neighbours : est un vecteur contenant les paires de cellules étant voisines.
\item convert : est une matrice permettant de retrouver le numéro d'une case du labyrinthe à partir de ses coordonnées.
\bigbreak
En effet, nous avons choisi d'utiliser la plupart du temps des entiers pour identifier les cases afin de pouvoir utiliser la structure \textit{UnionFind} préalablement définie (et qui contenait des entiers). Ainsi nous représentons chaque case par un chiffre de $0$ à $N *N - 1$
\end{itemize}

\subsection{Pseudocode} %d
\begin{codebox}
\Procname{$\proc{mzCreate}(size)$}
\li $\proc{Maze } maze$
\li $maze.size = size$
\li $maze.unionFind = \proc{ufCreate}(size)$
\li \While $\proc{ufComponentsCount}(maze.unionFind) > 1$
\Do
\li 	$(coord1, coord2) =$ a random pair of neighbours
\li		\If There is a wall
\li \Then Remove it
\li	$\proc{ufUnion}(maze.unionFind, coord1, coord2)$
\End
\End
\li \Return $maze$
\End
\end{codebox}

\begin{codebox}
\Procname{$\proc{mzIsValid}(maze)$}
\li \If $\proc{ufComponentsCount}(maze.unionFind) > 1$
\li \Then \Return $false$
\li \Else
\li \Return $true$
\End
\End
\end{codebox}
	
\subsection{Complexité en temps avec UnionFindList} %e
\proc{mzIsValid}

\proc{mzIsValid} est constant puisqu'il s'agit simplement d'aller lire la taille de l'\textit{UnionFind}.

\section{Analyse empirique}
\subsection{} %a
JE SUIS OCCUPE A FAIRE CA :) 
\subsection{} %b
	

\end{document}
